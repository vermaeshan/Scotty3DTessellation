<p align="center">
  <b>everma@andrew.cmu.edu</b><br>
</p>

## Objective
Though we implemented various sub-division schemes as part of the assignment, techniques like PN triangle method and Phong tessellation better approximate curves through bezier surfaces. By allowing the user to specify tessellation factor, the aim to implement hardware tessellation in software.

![t](https://github.com/vermaeshan/Scotty3DTessellation/blob/master/images/mesh_black.jpg?raw=true)

##Tessellation Theory
The tessellation is the process that divides a polygon into smaller ones. Another definition is: tessellation allows to increase polygons density. Today tessellation can be done on GPU and provides several key benefits:

+**Compression**: using tessellation allows to reduce the memory footprint and bandwidth consumption by storing on disk only low resolution meshes.

+**Bandwidth** is improved because, instead of transferring all of the vertex data for a high-polygon mesh over the PCI-E bus, only the coarse mesh is sent to the GPU.

+**Scalability**: because of its recursive nature, subdivision naturally accommodates LOD rendering and adaptive approximation with a variety of metrics.

While tessellation can be done on hardware, it will be useful to see how the final output will look.

### PN Triangle Test
From the input vertices and normals, Curved PN Triangles [[Vlachos et al. 2001]](https://www.cise.ufl.edu/research/SurfLab/papers/00ati.pdf) generates
control points to represent a smooth, cubic Bezier triangle that interpolates across the three
input vertices.

![t](https://github.com/vermaeshan/Scotty3DTessellation/blob/master/images/pn.png?raw=true)

The cubic Bezier triangle can be evaluated given these control points with the following formula 

![t](https://github.com/vermaeshan/Scotty3DTessellation/blob/master/images/pn-eq.png?raw=true)

The control points are generated by interpolating geometric vertex locations, and projecting
them along their nearest normal, and in the case of the center control point, the averaged
normal. The formulae for generating these control points are given in the appendix.

### Phong Tessellation
Phong Tessellation draws inspiration from Phong Shading, a method that shades boundary
representations smoothly by interpolating normals used for lighting calculations. Phong
Tessellation [[Boubekeur and Alexa 2008]](http://perso.telecom-paristech.fr/~boubek/papers/PhongTessellation/PhongTessellation.pdf) generates tangent planes for each input vertex,
aligned to each input normal, and performs barycentric interpolation within the three defining
tangent planes of a triangle to find a newly generated point.
This process is illustrated in Figure. A newly generated vertex p is projected onto the three
tangent planes, shown by the dotted green lines. The new vertex location p* is found by
barycentric interpolation of the tangent plane projections.

![t](https://github.com/vermaeshan/Scotty3DTessellation/blob/master/images/phong.png?raw=true)

We can define the projection operation of a point q onto the tangent plane associated with
vertex `vi` and normal `ni`

![t](https://github.com/vermaeshan/Scotty3DTessellation/blob/master/images/phong-eq.png?raw=true)

Given this projection, we can find the new location `p*` of an input vertex `p` by a simple matrix
multiplication

![t](https://github.com/vermaeshan/Scotty3DTessellation/blob/master/images/phong-eq1.png?raw=true)

## Outputs

![t](https://github.com/vermaeshan/Scotty3DTessellation/blob/master/images/trigs.gif?raw=true)

![t](https://github.com/vermaeshan/Scotty3DTessellation/blob/master/images/torus.gif?raw=true)

![t](https://github.com/vermaeshan/Scotty3DTessellation/blob/master/images/grid.gif?raw=true)

## User Guide
1. For PN Triangle Tessellation, Press E.
2. For Phong Tessellation, Press P. 

## Developer Manual
The update strategy and the process is similar to the one followed in Catmull-Clark or Linear Subdivision.

In particular, each triangle in the old mesh will consist of:

* one new vertex associated with a face from the original mesh,
* two new vertices associated with edges from the original mesh, and
* one vertex from the original mesh.

These values should be assigned to the members Face::newTessPosition, Edge::newTessPosition1, Edge::newTessPosition2, and Vertex::newTessPosition, respectively. For instance, f->newTessPosition = getPosition(...) will assign the new coordinates to the vertex vector associated with face f, dependent on the barycentric coordinates of the point and type of tessellation. The general strategy for assigning these new positions is to iterate over all faces assigning appropriate positions to the new vertices. 

Once the new vertex positions have been assigned to elements of the halfedge mesh, they need to be accumulated into a single list of all vertex positions in the new mesh, which will be handed to HalfedgeMesh::rebuild. It is important that vertex coordinates in this list appear in the same order they were indexed! For instance, if you index vertices, then 2 per edge, then faces, then the final vertex coordinate list should likewise contain coordinates from vertices, then coordinates from edges, then coordinates from faces. These vertex coordinates can be accumuluated using an object of type vector<Vector3D>, i.e., a dynamically-sized array of vertex positions. The basic strategy is to loop over all vertices, then all edges, then all faces, calling push_back to append each new vertex coordinate to the list.

NOTE: Specific ordering needs to be maintained for Edge::newTessPosition1/2, the definition to be used is: the new position closer to e->halfedge() is 1 and the other 2. To enable is, a new method in Edge Class was added which returns the vertex corresponding to the halfedge of the edge. This provides an anchor point for ordering.

Finally, since each triangle is subdivided in to 9 triangles, we need to associate each new face with the corresponding new vertices. This is probably the most tricky bit of this implementation. Specific ordering of the edges needs to be made for each new traingle so that rebuild() can function correctly.

New helper functions implemented:

### PN Triangle
1. Vector3D HalfedgeMesh::getPosition(...)
Given a point P, gets it barycentric coordinates, and given the control points(b*), extrapulates the poistion of the point.

2. void HalfedgeMesh::pnTriangle()
Calculates the control points for each face in the mesh and updates the newTesspositions taking care of edge ordering.

### Phong
3. Vector3D HalfedgeMesh::getPhongPosition(..)
Given a point P, gets it barycentric coordinates, and calculates the projections and extrapulates the poistion of the point.

4. void HalfedgeMesh::phong()
For each face in the mesh updates the newTesspositions taking care of edge ordering.

### Common Tessellation
5. Index HalfedgeMesh::getEdgeTessIndex(EdgeIter e, VertexIter v, int intendedIndex)
Helper function to get the correct new vertex position given an edge e and its anchor point v.

6. void assignTessellationIndices()
Iterates through vertices, edges and faces and assigns a unique index to each new vertex.

7. void buildTessellationFaceList( vector< vector<Index> >& subDFaces )
This is the most complex function as it assigns the 9 new faces correct vertex indices. And adds all the faces to a vector.

8. void buildTessellationVertexList( vector<Vector3D>& subDVertices )
Adds all the new vertexes to a vector maintaining index ordering

## Issues/ Work TBD
The barycentric interpolation is very susceptible to numerical stabilty and I ran in to issues getting correct output. Even though the implementation is correct, it is leading to weird artifacts and I had to roll back on the exact implementation.

## Authors and Contributors
All work will be done by Eshan. Alone. No partner. Solo.

## References
+[Smooth GPU Tessellation](https://people.eecs.berkeley.edu/~sequin/CS284/PROJ_12/Brandon/Smooth%20GPU%20Tessellation.pdf)

+[Tessellation on GPU, Curved PN Triangle](http://onrendering.blogspot.com/2011/12/tessellation-on-gpu-curved-pn-triangles.html)

+[10 Fun Things to do with Tessellation](http://www.ludicon.com/castano/blog/2009/01/10-fun-things-to-do-with-tessellation/)

+[OpenGL Tutorial 30](http://ogldev.atspace.co.uk/www/tutorial30/tutorial30.html)

+[OpenGL Tutorial 31](http://ogldev.atspace.co.uk/www/tutorial31/tutorial31.html)

+[History of Hardware Tessellation](http://rastergrid.com/blog/2010/09/history-of-hardware-tessellation/)
